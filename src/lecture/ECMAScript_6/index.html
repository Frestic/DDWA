<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>ECMADcript 6</title>
	<meta name="description" content="">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h1>ECMAScript 6</h1>
					<h3>Разработка динамичесих веб приложений</h3>
					<p>
						<small>Гладкий Максим Валерьевич / <a href="https://github.com/MaksHladki">github:MaksHladki</a></small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<!-- Содержимое лекции -->
			<section>
				<h2>Долгие 10 лет</h2>
				<img src="img/history.png" alt="">
			</section>
			<section>
				<h2>Как вдруг...</h2>
				<blockquote>
					17 июня 2015 года генеральное собрание Ecma International официально одобрило стандарт ECMA-262 6 версии
				</blockquote>
				<ul>
					<li>Стандарт ECMA-262</li>
					<li>ECMAScript 6</li>
					<li>ECMAScript 2015</li>
					<li>ECMAScript Harmony: улучшения после ECMAScript 5 (ES6 и ES7)</li>
					<li>ECMAScript.next: кодовое название ECMAScript 6</li>
				</ul>
			</section>
			<section>
				<h1>Блочная область видимости (let и const)</h1>
			</section>
			<section>
				<section>
					<h2>Обасть видимости ES5 - функция</h2>
					<pre>
				<code class="hljs" data-trim="">
var num = 10;

var func = function() {
    var num = 20;
    console.log(num); // 20
};

console.log(num); // 10
				</code>
				</pre>
				</section>
				<section>
					<h3>Глобальное окружение</h3>
					<pre>
					<code class="hljs">
if (true) {
    var a = 10;
}

console.log(a); // 10
					</code>
				</pre>
					<pre>
					<code class="hljs">
var a;
if (false) {
    a = 10;
}

console.log(a); // undefined
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h2>Оператор let</h2>
				<blockquote>
					Позволяет объявить локальную переменную с областью видимости, ограниченной текущим блоком кода .
				</blockquote>
				<pre>
					<code class="hljs">
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];

//var1, var2, …, varN - имя переменной (любой допустимый идентификатор)
//value1, value2, …, valueN - значение переменной (любое допустимое выражение)
					</code>
					</pre>
			</section>
			<section>
				<section>
					<h2>Особенности let</h2>
					<p>
						Область видимости переменной let – блок {...}
					</p>
					<pre>
					<code class="hljs">
var apples = 5;

if (true) {
  var apples = 10;
  console.log(apples); // 10 (внутри блока)
}
console.log(apples); // 10 (снаружи блока то же самое)
					</code>
				</pre>
					<pre>
					<code class="hljs">
let apples = 5;

if (true) {
  let apples = 10;
  console.log(apples); // 10 (внутри блока)
}
console.log(apples); // 5 (снаружи блока значение не изменилось)
					</code>
				</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<pre>
						<code class="hljs">
if (true) {
  let apples = 10;
  console.log(apples); // 10 (внутри блока)
}

console.log(apples); // ReferenceError: apples is not defined
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<p>Переменная let видна только после объявления</p>
					<pre>
						<code class="hljs">
console.log(a); // undefined
var a = 5;
						</code>
					</pre>
					<pre>
						<code class="hljs">
console.log(a); // ReferenceError: a is not defined
let a = 5;
						</code>
					</pre>
					<pre>
						<code class="hljs">
let x;
let x; // SyntaxError: Identifier 'x' has already been declared
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<p>При использовании в цикле, для каждой итерации создаётся своя переменная</p>
					<pre>
						<code class="hljs">
for(var i=0; i<10; i++) { 
	console.log(i); // 0, 1, 2, 3, 4 ... 9
}

console.log(i); // 10
						</code>
					</pre>
					<pre>
						<code class="hljs">
for (let i = 0; i<10; i++) {
  console.log(i); // 0, 1, 2, 3, 4 ... 9
}

console.log(i); // i is not defined	
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<pre>
						<code class="hljs">
function shooterBuilder() {
  let shooters = [];

  for (let i = 0; i < 10; i++) {
    shooters.push(function() {
      console.log(i);
    });
  }

  return shooters;
}

var x = shooterBuilder();
x[0](); // 0
x[5](); // 5
//c var было бы 10 10
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Оператор const</h2>
					<blockquote>
						Значение констант не может быть изменено новым присваиванием, а также не может быть переопределено. Константы (const) подчиняются
						области видимости уровня блока.
					</blockquote>
					<pre>
					<code class="hljs">
const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];

//nameN - имя константы (те же правила, что и для идентификаторов переменных)
//valueN - значение константы
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="hljs">
const apple = 5;
apple = 10; // ошибка
					</code>
				</pre>
					<pre>
					<code class="hljs">
const user = {
  name: "Alex"
};

user.name = "Maks"; // допустимо
user = 5; // ошибка
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="hljs">
const lit = 4;
lit = 5; // TypeError: Литерал изменить нельзя

const obj = { a: 1 };
obj.a = 2; // Значения внутри объекта изменить можно
console.log(obj); // { a: 2 }
obj = { a: 3 }; // TypeError: Ссылку менять нельзя

const arr = [1, 2, 3];
arr.push(4); // Значения внутри массива изменить можно
console.log(arr); // [1, 2, 3, 4]
obj = [4, 3, 2, 1]; // TypeError: Ссылку менять нельзя
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h1>Деструктуризация (destructuring assignment)</h1>
			</section>
			<section>
				<h2>Деструктуризация</h2>
				<blockquote>
					Деструктуризация – особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным,
					разбив его на части
				</blockquote>
				<ul>
					<li>Деструктуризация позволяет привязывать данные при совпадении паттерна</li>
					<li>Поддерживается для массивов и объектов</li>
					<li>Деструктуризация устойчива к ошибкам и во многом похожа на поиск поля в объеке</li>
					<li>Возвращает undefined, если что-то пошло не так</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Деструктуризация массива</h2>
					<pre>
					<code class="hljs">
let [firstName, lastName] = ['Иван', 'Иванов'];

console.log(firstName); // Иван
console.log(lastName);  // Иванов
					</code>
				</pre>
				</section>
				<section>
					<h2>
						Пропуск элементов
					</h2>
					<pre>
					<code class="hlljs">				
// первый и второй элементы не нужны
let [, , middleName] = "Иванов Иван Иванович (1971)".split(" ");

console.log(middleName); // Иванович
					</code>
				</pre>
					<p>Первый и второй, а также все элементы после третьего никуда не записались, они были отброшены</p>
				</section>
				<section>
					<h3>Оператор spread</h3>
					<pre>
					<code class="hljs">
let [fisrt, last, ...rest] = "Все ЛР должны быть сданы".split(" ");

console.log(first); // Все
console.log(last);  // ЛР
console.log(rest);  // должны быть сданы (массив из 3х элементов)
					</code>
				</pre>
					<ul>
						<li>Значением rest будет массив из оставшихся элементов</li>
						<li>Вместо rest можно использовать другое имя переменной</li>
						<li>Оператор spread - троеточие</li>
						<li>Spread должн стоять только последним элементом</li>
					</ul>
				</section>
				<section>
					<h3>Значения по умолчанию</h3>
					<pre>
						<code class="hljs">
let [firstName, lastName] = [];
console.log(firstName); // undefined
						</code>
					</pre>
					<pre>
						<code class="hljs">
let [firstName="Гость", lastName="Анонимный"] = [];

console.log(firstName); // Гость
console.log(lastName);  // Анонимный
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще пример</h3>
					<pre>
						<code class="hljs">
function defaultLastName() {
  return Date.now() + '-visitor';
}

// lastName получит значение, соответствующее текущей дате:
let [firstName, lastName=defaultLastName()] = ["Вася"];

console.log(firstName); // Вася
console.log(lastName);  // 1436...-visitor
						</code>
					</pre>
				</section>
				<section>
					<h3>Отделение объявления от присваивания</h3>
					<pre>
						<code class="hljs">
let a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2
						</code>
					</pre>
				</section>
				<section>
					<h3>Swapping</h3>
					<pre>
						<code class="hljs">
var a = 1;
var b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
						</code>
					</pre>
				</section>
				<section>
					<h3>Использование возвращающей функции</h3>
					<pre>
						<code class="hljs">
function f() {
  return [1, 2];
}

var a, b; 
[a, b] = f(); 
console.log(a); // 1
console.log(b); // 2
						</code>
					</pre>
				</section>
				<section>
					<h3>Работа c другими коллекциями</h3>
					<pre>
						<code class="hljs">
// Строки
var [a, b, c] = 'xyz';
console.log(a, b, b); // x y z
						</code>
					</pre>
					<pre>
						<code class="hljs">
// Коллекции DOM элементов
var [link1, link2] = document.links;
console.log(link1.tagName); // a
console.log(link2.textContent); // Пример
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Деструктуризация объектов</h2>
					<pre>
						<code class="hljs">
let {var1, var2} = {var1:…, var2…}
						</code>
					</pre>
					<ul>
						<li>Указываем, какие свойства в какие переменные должны «идти»</li>
						<li>Объект справа – существующий объект</li>
						<li>Список слева – список переменных, в которые записываются соответствующие свойства</li>
					</ul>
				</section>
				<section>
					<h3>Использование возвращающей функции</h3>
					<pre>
						<code class="hljs">
var calc = function(num) {
  return Math.pow(num, 2);
};

var { prop: x, pow: y = calc(x)} = { prop: 4 };
console.log(x, y); // 4 16

var { prop: x, pow: y = calc(x)} = { prop: 4, pow: 10 };
console.log(x, y); // 4 10
						</code>
					</pre>
				</section>
				<section>
					<h3>Простой пример</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

console.log(title);  // Меню
console.log(width);  // 100
console.log(height); // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Другое имя переменной</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {width: w, height: h, title} = options;

console.log(title);  // Меню
console.log(w);      // 100
console.log(h);      // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Значение по умолчанию</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню"
};

let {width=100, height=200, title} = options;

console.log(title);  // Меню
console.log(width);  // 100
console.log(height); // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Combo: новое имя + значение по умолчанию</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню"
};

let {width:w=100, height:h=200, title} = options;

console.log(title);  // Меню
console.log(w);      // 100
console.log(h);      // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Отделение объявления от присваивания</h3>
					<pre>
						<code class="hljs">
var width, height;
({width, height} = {width: 100,height: 200});
console.log(width);// 100
console.log(height);// 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Использование конкретного имени</h3>
					<pre>
						<code class="hljs">
let key = "title";
let { [key]: t } = {title: "Меню"};

console.log(t); // Меню
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Вложенные деструктуризации</h2>
				<pre>
					<code class="hljs">
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Пончик", "Пирожное"]
}

let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

// Меню 100 200 Пончик Пирожное
console.log(title);  // Меню
console.log(width);  // 100
console.log(height); // 200
console.log(item1);  // Пончик
console.log(item2);  // Пирожное
					</code>
				</pre>
			</section>
			<section>
				<h1>Функции</h1>
			</section>
			<section>
				<section>
					<h2>Параметры по умолчанию</h2>
					<pre>
					<code class="hljs">
function [name]([param1[ = defaultValue1 ][, ..., paramN[ = defaultValueN ]]]) {
   //function's body
}
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
function multiply(a, b = 1) {
  return a*b;
}

multiply(5); // 5
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример с undefined</h3>
					<blockquote>
						Даже при явном указании undefined параметру присваивается значение по умолчанию
					</blockquote>
					<pre>
						<code class="hljs">
function multiply(a, b = 1) {
  return a*b;
}

multiply(5, undefined); // 5		
						</code>
					</pre>
				</section>
				<section>
					<h3>Вычисление во время вызова</h3>
					<pre>
						<code class="hljs">
function append(value, array = []) {
  array.push(value);
  return array;
}

append(1); //[1]
append(2); //[2]
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример с функцией</h3>
					<pre>
						<code class="hljs">
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function print(number = getRandomInt(10, 100)){
   console.log(number);
}
print();//29
						</code>
					</pre>
				</section>
				<section>
					<h3>Оператор spread</h3>
					<blockquote>
						В отличии от arguments, rest - массив, а значит, можно использовать методы map, forEach и другие
					</blockquote>
					<pre>
						<code class="hljs">
function printName(firstName, lastName, ...rest) {
  console.log(firstName + ' ' + lastName + ' - ' + rest);
  console.log(rest);
}
printName('Иван', 'Иванов', 'Иванович', '1959');
//Иван Иванов - Иванович,1959
//["Иванович", "1959"]
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство name</h3>
					function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min)) + min; } console.log(getRandomInt.name);//getRandomInt
					getRandomInt.name = 'f'; console.log(getRandomInt.name); //getRandomInt console.log(f.name);// ReferenceError: f is
					not defined
				</section>
				<section>
					<h3>Блочная модель видимости</h3>
					<pre>
						<code class="hljs">
if(something){
getRandomInt(0, 10);//4
	function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}
}

getRandomInt(0, 10);//ReferenceError: getRandomInt is not defined
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Стрелочные функции</h2>
					<blockquote>
						Выражения имеют более короткий синтаксис и лексически привязаны к значению this, всегда анонимные
					</blockquote>
					<pre>
					<code class="hljs" data-trim>
						(param1, param2, paramN) => expression
					</code>
						</pre>
					<small>
					<ul>
						<li>Лексическое связывание. Значения this, super и arguments определяются не тем, как стрелочные
							функции были вызваны, а тем, как они были созданы</li>
						<li>Неизменяемые this, super и arguments. Значения этих переменных внутри стрелочных функций остаются неизменными на протяжении
							всего жизненного цикла функции</li>
						<li>Стрелочные функции не могут быть использованы как конструктор</li>
						<li>Недоступность «собственного» значения переменной arguments</li>
					</ul>
					</small>
				</section>
				<section>
					<h3>Короткая запись</h3>
					<pre>
					<code class="hljs">
var faculties = [
  "ИТ",
  "ИЭФ",
  "ХТИТ"
];

var a = faculties.map(function(s){ return s.length });//[2,3,4]

var b = faculties.map( s => s.length);//[2,3,4]
					</code>
				</pre>
				</section>
				<section>
					<h3>Еще примеры</h3>
					<pre>
						<code class="hljs">
let square = x => x*x;
console.log(square(3));//9
						</code>
					</pre>
					<pre>
						<code class="hljs">
let sum => (x, y) => x + y;
console.log(sum(3,4));//7
						</code>
					</pre>
					<pre>
						<code class="hljs">
let getObject = () => ({ brand: 'BMW' });
console.log(getObject());//Object {brand: "BMW"}
						</code>
					</pre>
					<pre>
						<code class="hljs">
let func = () => 77;
console.log(func());//77
						</code>
					</pre>
				</section>
				<section>
					<h3>Отсутствие this</h3>
					<pre>
					<code class="hljs">
 var handler = {
    id: "123456",
    init: function() {
        document.addEventListener("click", ev => this.doSomething(ev.type));
        //this указывает на внешний контекст
    },
    doSomething: function(type) { 
        console.log("Handling " + type  + " for " + this.id);
    }
};
					</code>
				</pre>
				</section>
				<section>
					<h3>Отсутствие arguments</h3>
					<pre>
						<code class="hljs">
function foo() {
  var f = (i) => arguments[0]+i;
  //возмет arguments из функции foo
  console.log(f(2));
}

foo(1); // 3
						</code>
					</pre>
				</section>
				<section>
					<h3>Отсутсвие запуска с new</h3>
					<pre>
						<code class="hljs">
var a = new (function() {}); 
// переменной a будет присвоено значение экземпляра анонимной функции

var b = new (() => {}); 
//TypeError: (intermediate value) is not a constructor
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Строки</h1>
			</section>
			<section>
				<section>
					<h2>Шаблонные строки</h2>
					<blockquote>
						Выглядят как обычные строки за исключением того, что обернуты символами обратных кавычек <span class="highlight-blue"><b>`</b></span>
					</blockquote>
					<pre>
						<code class="hljs">
`строка текста`

`строка текста 1
 строка текста 2`

`строка текста ${выражение} строка текста`

tag `строка текста ${выражение} строка текста`
						</code>
					</pre>
				</section>
				<section>
					<h3>Многострочные литералы</h3>
					<pre>
						<code class="hljs">
console.log(`string text line 1
string text line 2`);
// "string text line 1
//  string text line 2"
						</code>
					</pre>
				</section>
				<section>
					<h3>Интерполяция выражений</h3>
					<pre>
						<code class="hljs">
let apples = 2;
let oranges = 3;

console.log(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще примеры</h3>
					<pre>
						<code class="hljs">
function authorize(user, action) {
  if (!user.hasPrivilege(action)) {
    throw new Error(
      `Пользователю ${user.name} не разрешено ${action}.`);
  }
}
						</code>
					</pre>
					<pre>
						<code class="hljs">
const up = (str) => str.toUpperCase();
let str = `this is ${ up('sting') } in uppercase`;
console.log(str); // this is STRING in uppercase
						</code>
					</pre>
				</section>
				<section>
					<h3>Вложенная Интерполяция</h3>
					<pre>
						<code class="hljs">
const up = (str) => str.toUpperCase();
let user = 'user';
let str = `these ${up(`${user}s`)} are great`;
console.log(str); // these USERS are great
						</code>
					</pre>
				</section>
				<section>
					<h3>Улучшеная поддержка юникода</h3>
					<p>UTF-16 = символ состоит из 2 байт</p>
					<pre>
						<code class="hljs">
console.log( '我'.length ); // 1
console.log( '𩷶'.length ); // 2
//расширенная поодерэка метасимволов, математических символов и смайликов
console.log( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
console.log( '😂'.length ); // 2, FACE WITH TEARS OF JOY
						</code>
					</pre>
				</section>
				<section>
					<h3>Новые методы</h3>
					<ul>
						<li>str.includes(s)</li>
						<li>str.endsWith(s)</li>
						<li>str.startsWith(s)</li>
						<li>str.repeat(times)</li>
					</ul>
				</section>
				<section>
					<h3>Метод includes</h3>
					<blockquote>
						Проверяет, включает ли одна строка в себя другую, возвращает true/false
					</blockquote>
					<pre>
						<code class="hljs">
str.includes(searchString[, position])
						</code>
					</pre>
					<pre>
						<code class="hljs">
var str = 'To be, or not to be, that is the question.';

console.log(str.includes('To be'));       // true
console.log(str.includes('question'));    // true
console.log(str.includes('nonexistent')); // false
console.log(str.includes('To be', 1));    // false
console.log(str.includes('TO BE'));       // false
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод endsWith</h3>
					<blockquote>
						Возвращает true, если строка str заканчивается подстрокой searchString
					</blockquote>
					<pre>
						<code class="hljs">
str.endsWith(searchString[, position])
						</code>
					</pre>
					<pre>
						<code class="hljs">
var str = 'To be, or not to be, that is the question.';

console.log(str.endsWith('question.')); // true
console.log(str.endsWith('to be'));     // false
console.log(str.endsWith('to be', 19)); // true
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод startsWith</h3>
					<blockquote>
						Возвращает true, если строка str начинается со строки searchString
					</blockquote>
					<pre>
						<code class="hljs">
str.startsWith(searchString[, position])
						</code>
					</pre>
					<pre>
						<code class="hljs">
var str = 'To be, or not to be, that is the question.';

console.log(str.startsWith('To be'));         // true
console.log(str.startsWith('not to be'));     // false
console.log(str.startsWith('not to be', 10)); // true
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод repeat</h3>
					<blockquote>
						Повторяет строку str count раз
					</blockquote>
					<pre>
						<code class="hljs">
str.repeat(count)
						</code>
					</pre>
					<pre>
						<code class="hljs">
'abc'.repeat(-1);   // RangeError
'abc'.repeat(0);    // ''
'abc'.repeat(1);    // 'abc'
'abc'.repeat(2);    // 'abcabc'
'abc'.repeat(3.5);  // 'abcabcabc' (count will be converted to integer)
'abc'.repeat(1/0);  // RangeError
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Функции шаблонизации</h2>
					<p>Использование свой функции шаблонизации для строк</p>
					<pre>
					<code class="hljs">
let str = func`моя строка`;
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
function f(strings, ...values) {
  console.log(JSON.stringify(strings));     // ["Sum of "," + "," =\n ","!"]
  console.log(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]
  console.log(JSON.stringify(values));      // [3,5,8]
}

let apples = 3;
let oranges = 5;

//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]
let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
						</code>
					</pre>
				</section>
				<section>
					<h3>Необрабатываемые строки</h3>
					<blockquote>
						Статический метод, является теговой функцией для шаблонных строк и используется для получения необработанной строки из шаблона
					</blockquote>
					<pre>
						<code class="hljs">
String.raw(callSite, ...substitutions)

String.raw`templateString`
						</code>
					</pre>
					<pre>
						<code class="hljs">
function tag(strings, ...values) {
  return strings.raw[0];
}

tag`string text line 1 \n string text line 2`;
// "string text line 1 \\n string text line 2"
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Symbol</h1>
			</section>
			<section>
				<section>
					<h2>Тип данных Symbol</h2>
					<blockquote>
						Символ — это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов
					</blockquote>
					<blockquote>
						Символьный объект — это объект-обёртка (англ. wrapper) для примитивного символьного типа
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
							Symbol([описание])//новый 7-мой тип данных
						</code>
					</pre>
					<p>Вызывая Symbol() создается новый символ, значение которого не равно любому другому объекту</p>
				</section>
				<section>
					<h3>Примеры</h3>
					<pre>
						<code class="hljs">
var sym1 = Symbol();
var sym2 = Symbol("foo");
var sym3 = Symbol("foo");
						</code>
					</pre>
					<pre>
						<code class="hljs">
var sym = Symbol("foo");
typeof sym;     // "symbol" 
var symObj = Object(sym);
typeof symObj;  // "object"
console.log(Symbol("name") == Symbol("name")); // false
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще пример</h3>
					<pre>
						<code class="hljs">
let isAdmin = Symbol("isAdmin");

let user = {
  name: "Вася",
  [isAdmin]: true
};

console.log(user[isAdmin]); // true
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще один</h3>
					<blockquote>
						Свойство объявленное через символ не будет видно в for-in, Object.keys, Object.getOwnPropertyNames, также не будет добавлено
						при использовании JSON.stringify
					</blockquote>
					<pre>
						<code class="hljs">
let user = {
  name: "Вася",
  age: 30,
  [Symbol.for("isAdmin")]: true
};

// в цикле for..in не будет символа
console.log(Object.keys(user)); // name, age

// доступ к свойству через глобальный символ — работает
console.log(user[Symbol.for("isAdmin")]);
						</code>
					</pre>
				</section>
				<section>
					<h3>Использование для private-членов</h3>
					<pre>
						<code class="hljs">
var role = Symbol();
var user = {
    id: 1001,
    name: 'Administrator',
    [role]: 'admin'
};

var userRole = user[role]; // 'admin' - работает
var userRole1 = user.role; // undefined - не работает
var userRole2 = user['role']; // undefined - не работает
						</code>
					</pre>
				</section>
				<section>
					<h3>Глобальные символы</h3>
					<blockquote>
						«Глобальный реестр» символов позволяет иметь общие «глобальные» символы, которые можно получить из реестра по имени. Для
						чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя)
					</blockquote>
					<pre>
						<code class="hljs">
// создание символа в реестре
let name = Symbol.for("name");

// символ уже есть, чтение из реестра
console.log(Symbol.for("name") == name); // true
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Встроенные символы</h2>
				<small>
				<table>
					<tr>
						<td>Symbol.iterator</td>
						<td>возвращающий итератор для объекта</td>
					</tr>
					<tr>
						<td>Symbol.match</td>
						<td>сопоставление объекта со строкой (String.prototype.match)</td>
					</tr>
					<tr>
						<td>Symbol.replace</td>
						<td>заменяет совпавшие подстроки в строке (String.prototype.replace)</td>
					</tr>
					<tr>
						<td>Symbol.search</td>
						<td>возвращает индекс вхождения подстроки, соответствующей регулярному выражению (String.prototype.search)</td>
					</tr>
					<tr>
						<td>Symbol.split</td>
						<td>разбиваtn строку на части в местах, соответствующих регулярному выражению (String.prototype.split)</td>
					</tr>
					<tr>
						<td>Symbol.for(key)</td>
						<td>ищет существующие символы по заданному ключу и возвращает его, если он найден</td>
					</tr>
					<tr>
						<td>Symbol.species</td>
						<td>определяет конструктор для порожденных объектов</td>
					</tr>
				</table>
				</small>
			</section>
			<section>
				<h1>Объекты и прототипы</h1>
			</section>
			<section>
				<section>
					<h2>Короткое свойство</h2>
					<blockquote>
						При объявлении свойства объекта достаточно указать только его имя, а значение будет взято из переменной с аналогичным именем
					</blockquote>
					<pre>
						<code class="hljs">
let name = "Вася";
let isAdmin = true;

let user = {
  name,
  isAdmin
};
console.log(JSON.stringify(user)); // {"name": "Вася", "isAdmin": true}
						</code>
					</pre>
				</section>
				<section>
					<h3>Вычисляемые свойства</h3>
					<pre>
						<code class="hljs">
let propName = "firstName";

let user = {
  [propName]: "Вася"
};

console.log(user.firstName); // Вася
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
let a = "Зелёный ";
let b = "Крокодил";

let user = {
  [(a + b).toLowerCase()]: "Петя"
};

console.log( user["зелёный крокодил"] ); // Петя
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод setPrototypeOf</h3>
					<blockquote>
						Метод устанавливает прототип (внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null
					</blockquote>
					<pre>
						<code class="hljs">
Object.setPrototypeOf(obj, prototype);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var dict = Object.setPrototypeOf({}, null);
						</code>
					</pre>
				</section>
				<section>
					<h3>Object.assign</h3>
					<blockquote>
						Метод используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов
						в целевой объект
					</blockquote>
					<pre>
						<code class="hljs">
Object.assign(target, src1, src2...)
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
var o1 = { a: 1 };
var o2 = { b: 2 };
var o3 = { c: 3 };

var obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }
// изменился и сам целевой объект
						</code>
					</pre>
				</section>
				<section>
					<h3>Object.is</h3>
					<blockquote>
						Метод определяет, являются ли два значения одинаковыми значениями
					</blockquote>
					<pre>
						<code class="hljs">
var isSame = Object.is(value1, value2);
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
Object.is('foo', 'foo');     // true
Object.is(window, window);   // true

Object.is('foo', 'bar');     // false
Object.is([], []);           // false

var test = { a: 1 };
Object.is(test, test);       // true

Object.is(null, null);       // true

// Специальные случаи
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
Object.is(NaN, NaN);         // true
						</code>
					</pre>
				</section>
				<section>
					<h3>Объявление метода</h3>
					<p>Более короткий и удобный синтаксис</p>
					<pre>
						<code class="hljs">
let name = "Вася";
let user = {
  name,
  //something: function()
  //{
  //console.log(this.name);
  //}	  
  something() {
    console.log(this.name);
  }
};
user.something(); // Вася
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Классы</h1>
			</section>
			<section>
				<section>
					<h2>Объявление класса</h2>
					<pre>
							<code class="hljs">
class Название [extends Родитель]  {
  constructor
  методы
}
							</code>
						</pre>
					<pre>
						<code class="hljs">
class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Выражение класса</h3>
					<pre>
							<code class="hljs">
// безымянный
var Polygon = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};

// именованный
var Polygon = class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
							</code>
						</pre>
				</section>
				<section>
					<h3>Создание объекта и прототип</h3>
					<blockquote>
						Constructor запускается при создании new Object, остальные методы записываются в Object.prototype
					</blockquote>
					<pre>
							<code class="hljs">
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() { console.log(this.name);}
}
let user = new User("Вася");
							</code>
						</pre>
					<pre>
							<code class="hljs">
function User(name) {
  this.name = name;
}
User.prototype.sayHi = function() {
	console.log(this.name);
};
							</code>
						</pre>
				</section>
				<section>
					<h3>Подъем (hoisting)</h3>
					<p class="text">Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление
						функции совершает подъём (hoisted), в то время как объявление класса — нет</p>
					<pre>
						<code class="hljs">
var p = new Polygon(); // ReferenceError

class Polygon {}
						</code>
					</pre>
				</section>
				<section>
					<h3>Статические методы</h3>
					<pre>
						<code class="hljs">
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;

        return Math.sqrt(dx*dx + dy*dy);
    }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);

console.log(Point.distance(p1, p2));
						</code>
					</pre>
				</section>
				<section>
					<h3>Геттеры, сеттеры</h3>
					<pre>
						<code class="hljs">
class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(newValue) {
    [this.firstName, this.lastName] = newValue.split(' ');
  }
};
						</code>
					</pre>
				</section>
				<section>
					<h3>Вычисляемые имена методов</h3>
					<pre>
					<code class="hljs">
class Foo() {
    myMethod() {}
}
					</code>
				</pre>
					<pre>
					<code class="hljs">
class Foo() {
    ['my'+'Method']() {}
}
					</code>
				</pre>
					<pre>
					<code class="hljs">
const m = 'myMethod';
class Foo() {
    [m]() {}
}
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Наследование</h2>
					<blockquote>
						Только один конструктор, прототип, базовый класс!
					</blockquote>
					<pre>
						<code class="hljs">
class Child extends Parent {
  //TODO logic
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}

class ColorPoint extends Point {
    constructor(color) {
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color;
    }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Наследование статических методов</h3>
					<pre>
						<code class="hljs">
class Foo {
    static classMethod() {
        return 'hello';
    }
}

class Bar extends Foo {
	//TODO
}
Bar.classMethod(); // 'hello'
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Super</h2>
					<blockquote>
						Используется для вызова функций, принадлежащих родителю объекта
					</blockquote>
					<pre>
					<code class="hljs">
super([arguments]); //вызов родительского конструктора 
super.functionOnParent([arguments]);
					</code>
				</pre>
				</section>
				<section>
					<h3>Вызов конструктора</h3>
					<pre>
					<code class="hljs">
class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(length) {
    super(length, length);
  }

  get area() {
    return this.height * this.width;
  }
}
					</code>
				</pre>
				</section>
				<section>
					<h3>Вызов метода</h3>
					<pre>
						<code class="hljs">
class Foo {
    static classMethod() {
        return 'hello';
    }
}

class Bar extends Foo {
    static classMethod() {
        return super.classMethod() + ', too';
    }
}
Bar.classMethod(); // 'hello, too'
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Mixins</h2>
					<blockquote>
						Абстрактные подклассы (mix-ins) — это шаблоны для классов. У класса в ECMAScript может быть только один родительский класс,
						поэтому множественное наследование невозможно. Функциональность должен предоставлять родительскй класс
					</blockquote>
					<pre>
						<code class="hljs">
class B extends A, M {}//множественного наследования нет  

const mixin = base => class extends base {
  /* свойства и методы */
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
class Person { ··· }

const Storage = Sup => class extends Sup {
    save(database) { ··· }
};
const Validation = Sup => class extends Sup {
    validate(schema) { ··· }
};

class Employee extends Storage(Validation(Person)) { ··· }
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще пример</h3>
					<pre>
						<code class="hljs">
let MyMixin = (superclass) => class extends superclass {  
  test() {
    console.log('test from MyMixin');
  }
};

class MyClass extends MyMixin(MyBaseClass) {  
  /* ... */
}

let c = new MyClass();  
c.test(); // test from MyMixin
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Итераторы</h1>
			</section>
			<section>
				<section>
					<h2>Всемогущественный for...of</h2>
					<blockquote>
						Оператор выполняет цикл обхода итерируемых объектов, вызывая на каждом
						шаге итерации операторы для каждого значения из различных свойств объекта
					</blockquote>
					<pre>
						<code class="hljs">
for (переменная of объект)
  оператор
						</code>
					</pre>
					<ul>
						<li>При итерациях используется значение, а не ключ</li>
						<li>Можно использовать continue и break</li>
						<li>Используется с Array, Map, Set, Object и т.д.</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
let arr = [ 3, 5, 7 ];
arr.foo = "hello";

for (let i in arr) {
   console.log(i); // "0", "1", "2", "foo"
}

for (let i of arr) {
   console.log(i); // "3", "5", "7"
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Разные типы данных</h3>
					<pre>
						<code class="hljs">
// Строки
let result = '';
for (let chr of 'this is string') {
  result += chr.trim();
}
console.log(result); // thisisstring

// Коллекции DOM элементов
let result = [];
for (let link of document.links) {
  result.push(link.href);
}
console.log(result); // ['http://google.com', 'http://jsraccoon.ru', ...]
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Понятие итератора</h2>
					<blockquote>
						Объект является итератором, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая свое текущее
						положение внутри этой последовательности
					</blockquote>
					<blockquote>
						В JavaScript итератор - это объект, который предоставляет метод next(), возвращающий следующий элемент последовательности.
						Этот метод возвращает объект с двумя свойствами: done и value
					</blockquote>
				</section>
				<section>
					<h3>Спецификация</h3>
					<pre>
						<code class="hljs">
interface Iterable {
    [Symbol.iterator]() : Iterator;
}

interface Iterator {
    next() : IteratorResult;
}

interface IteratorResult {
    value: any;
    done: boolean;
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Итерируемые значения</h3>
					<ul>
						<li>Arrays</li>
						<li>Strings</li>
						<li>Maps</li>
						<li>Sets</li>
						<li>DOM data structures</li>
					</ul>
				</section>
				<section>
					<h3>Сфера применения</h3>
					<img src="img/iterator.jpg" alt="">
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
function makeIterator(array){
    var nextIndex = 0;
    
    return {
       next: function(){
           return nextIndex < array.length ?
               {value: array[nextIndex++], done: false} :
               {done: true};
       }
    }
}

var it = makeIterator(['yo', 'ya']);
console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done);  // true
						</code>
					</pre>
				</section>
				<section>
					<h3>Добавление к существующему объекту</h3>
					<pre>
						<code class="hljs" data-trim>
let range = {
  from: 1,
  to: 5
}

range[Symbol.iterator] = function() {
  let current = this.from;
  let last = this.to;

  return {
    next() {
      if (current <= last) {
        return {done: false, value: current++};
      } else {
        return {done: true};
      }
    }
  }
};
//for (let num of range)
						</code>
					</pre>
				</section>
				<section>
					<h3>Бесконечный итератор</h3>
					<pre>
						<code class="hljs">
function idMaker(){
    var index = 0;
    
    return {
       next: function(){
           return {value: index++, done: false};
       }
    }
}

var it = idMaker();

console.log(it.next().value); // '0'
console.log(it.next().value); // '1'
console.log(it.next().value); // '2'
//.....
						</code>
					</pre>
				</section>
				<section>
					<h3>Встроенный итератор</h3>
					<pre>
						<code class="hljs">
let str = "Hello";

let iterator = str[Symbol.iterator]();

while(true) {
  let result = iterator.next();
  if (result.done) break;
  console.log(result.value); // 'H' 'e' 'l' 'l' 'o'
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще пример</h3>
					<pre>
						<code class="hljs">
var someString = "hi";
var iterator = someString[Symbol.iterator]();

console.log(iterator + "");    // "[object String Iterator]"
 
console.log(iterator.next());  // { value: "h", done: false }
console.log(iterator.next());  // { value: "i", done: false }
console.log(iterator.next());  // { value: undefined, done: true }
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/thanks.jpg" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>