<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>ECMADcript 6</title>
	<meta name="description" content="">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h1>ECMAScript 6</h1>
					<h3>Разработка динамичесих веб приложений</h3>
					<p>
						<small>Гладкий Максим Валерьевич / <a href="https://github.com/MaksHladki">github:MaksHladki</a></small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<!-- Содержимое лекции -->
			<section>
				<h2>Долгие 10 лет</h2>
				<img src="img/history.png" alt="">
			</section>
			<section>
				<h2>Как вдруг...</h2>
				<blockquote>
					17 июня 2015 года генеральное собрание Ecma International официально одобрило стандарт ECMA-262 6 версии
				</blockquote>
				<ul>
					<li>Стандарт ECMA-262</li>
					<li>ECMAScript 6</li>
					<li>ECMAScript 2015</li>
					<li>ECMAScript Harmony: улучшения после ECMAScript 5 (ES6 и ES7)</li>
					<li>ECMAScript.next: кодовое название ECMAScript 6</li>
				</ul>
			</section>
			<section>
				<h1>Блочная область видимости (let и const)</h1>
			</section>
			<section>
				<section>
					<h2>Обасть видимости ES5 - функция</h2>
					<pre>
				<code class="hljs" data-trim="">
var num = 10;

var func = function() {
    var num = 20;
    console.log(num); // 20
};

console.log(num); // 10
				</code>
				</pre>
				</section>
				<section>
					<h3>Глобальное окружение</h3>
					<pre>
					<code class="hljs">
if (true) {
    var a = 10;
}

console.log(a); // 10
					</code>
				</pre>
					<pre>
					<code class="hljs">
var a;
if (false) {
    a = 10;
}

console.log(a); // undefined
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h2>Оператор let</h2>
				<blockquote>
					Позволяет объявить локальную переменную с областью видимости, ограниченной текущим блоком кода .
				</blockquote>
				<pre>
					<code class="hljs">
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];

//var1, var2, …, varN - имя переменной (любой допустимый идентификатор)
//value1, value2, …, valueN - значение переменной (любое допустимое выражение)
					</code>
					</pre>
			</section>
			<section>
				<section>
					<h2>Особенности let</h2>
					<p>
						Область видимости переменной let – блок {...}
					</p>
					<pre>
					<code class="hljs">
var apples = 5;

if (true) {
  var apples = 10;
  console.log(apples); // 10 (внутри блока)
}
console.log(apples); // 10 (снаружи блока то же самое)
					</code>
				</pre>
					<pre>
					<code class="hljs">
let apples = 5;

if (true) {
  let apples = 10;
  console.log(apples); // 10 (внутри блока)
}
console.log(apples); // 5 (снаружи блока значение не изменилось)
					</code>
				</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<pre>
						<code class="hljs">
if (true) {
  let apples = 10;
  console.log(apples); // 10 (внутри блока)
}

console.log(apples); // ReferenceError: apples is not defined
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<p>Переменная let видна только после объявления</p>
					<pre>
						<code class="hljs">
console.log(a); // undefined
var a = 5;
						</code>
					</pre>
					<pre>
						<code class="hljs">
console.log(a); // ReferenceError: a is not defined
let a = 5;
						</code>
					</pre>
					<pre>
						<code class="hljs">
let x;
let x; // SyntaxError: Identifier 'x' has already been declared
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<p>При использовании в цикле, для каждой итерации создаётся своя переменная</p>
					<pre>
						<code class="hljs">
for(var i=0; i<10; i++) { 
	console.log(i); // 0, 1, 2, 3, 4 ... 9
}

console.log(i); // 10
						</code>
					</pre>
					<pre>
						<code class="hljs">
for (let i = 0; i<10; i++) {
  console.log(i); // 0, 1, 2, 3, 4 ... 9
}

console.log(i); // i is not defined	
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенности let</h3>
					<pre>
						<code class="hljs">
function shooterBuilder() {
  let shooters = [];

  for (let i = 0; i < 10; i++) {
    shooters.push(function() {
      console.log(i);
    });
  }

  return shooters;
}

var x = shooterBuilder();
x[0](); // 0
x[5](); // 5
//c var было бы 10 10
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Оператор const</h2>
					<blockquote>
						Значение констант не может быть изменено новым присваиванием, а также не может быть переопределено. Константы (const) подчиняются
						области видимости уровня блока.
					</blockquote>
					<pre>
					<code class="hljs">
const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];

//nameN - имя константы (те же правила, что и для идентификаторов переменных)
//valueN - значение константы
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="hljs">
const apple = 5;
apple = 10; // ошибка
					</code>
				</pre>
					<pre>
					<code class="hljs">
const user = {
  name: "Alex"
};

user.name = "Maks"; // допустимо
user = 5; // ошибка
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="hljs">
const lit = 4;
lit = 5; // TypeError: Литерал изменить нельзя

const obj = { a: 1 };
obj.a = 2; // Значения внутри объекта изменить можно
console.log(obj); // { a: 2 }
obj = { a: 3 }; // TypeError: Ссылку менять нельзя

const arr = [1, 2, 3];
arr.push(4); // Значения внутри массива изменить можно
console.log(arr); // [1, 2, 3, 4]
obj = [4, 3, 2, 1]; // TypeError: Ссылку менять нельзя
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h1>Деструктуризация (destructuring assignment)</h1>
			</section>
			<section>
				<h2>Деструктуризация</h2>
				<blockquote>
					Деструктуризация – особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным,
					разбив его на части
				</blockquote>
				<ul>
					<li>Деструктуризация позволяет привязывать данные при совпадении паттерна</li>
					<li>Поддерживается для массивов и объектов</li>
					<li>Деструктуризация устойчива к ошибкам и во многом похожа на поиск поля в объеке</li>
					<li>Возвращает undefined, если что-то пошло не так</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Деструктуризация массива</h2>
					<pre>
					<code class="hljs">
let [firstName, lastName] = ['Иван', 'Иванов'];

console.log(firstName); // Иван
console.log(lastName);  // Иванов
					</code>
				</pre>
				</section>
				<section>
					<h2>
						Пропуск элементов
					</h2>
					<pre>
					<code class="hlljs">				
// первый и второй элементы не нужны
let [, , middleName] = "Иванов Иван Иванович (1971)".split(" ");

console.log(middleName); // Иванович
					</code>
				</pre>
					<p>Первый и второй, а также все элементы после третьего никуда не записались, они были отброшены</p>
				</section>
				<section>
					<h3>Оператор spread</h3>
					<pre>
					<code class="hljs">
let [fisrt, last, ...rest] = "Все ЛР должны быть сданы".split(" ");

console.log(first); // Все
console.log(last);  // ЛР
console.log(rest);  // должны быть сданы (массив из 3х элементов)
					</code>
				</pre>
					<ul>
						<li>Значением rest будет массив из оставшихся элементов</li>
						<li>Вместо rest можно использовать другое имя переменной</li>
						<li>Оператор spread - троеточие</li>
						<li>Spread должн стоять только последним элементом</li>
					</ul>
				</section>
				<section>
					<h3>Значения по умолчанию</h3>
					<pre>
						<code class="hljs">
let [firstName, lastName] = [];
console.log(firstName); // undefined
						</code>
					</pre>
					<pre>
						<code class="hljs">
let [firstName="Гость", lastName="Анонимный"] = [];

console.log(firstName); // Гость
console.log(lastName);  // Анонимный
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще пример</h3>
					<pre>
						<code class="hljs">
function defaultLastName() {
  return Date.now() + '-visitor';
}

// lastName получит значение, соответствующее текущей дате:
let [firstName, lastName=defaultLastName()] = ["Вася"];

console.log(firstName); // Вася
console.log(lastName);  // 1436...-visitor
						</code>
					</pre>
				</section>
				<section>
					<h3>Отделение объявления от присваивания</h3>
					<pre>
						<code class="hljs">
let a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2
						</code>
					</pre>
				</section>
				<section>
					<h3>Swapping</h3>
					<pre>
						<code class="hljs">
var a = 1;
var b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
						</code>
					</pre>
				</section>
				<section>
					<h3>Использование возвращающей функции</h3>
					<pre>
						<code class="hljs">
function f() {
  return [1, 2];
}

var a, b; 
[a, b] = f(); 
console.log(a); // 1
console.log(b); // 2
						</code>
					</pre>
				</section>
				<section>
					<h3>Работа c другими коллекциями</h3>
					<pre>
						<code class="hljs">
// Строки
var [a, b, c] = 'xyz';
console.log(a, b, b); // x y z
						</code>
					</pre>
					<pre>
						<code class="hljs">
// Коллекции DOM элементов
var [link1, link2] = document.links;
console.log(link1.tagName); // a
console.log(link2.textContent); // Пример
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Деструктуризация объектов</h2>
					<pre>
						<code class="hljs">
let {var1, var2} = {var1:…, var2…}
						</code>
					</pre>
					<ul>
						<li>Указываем, какие свойства в какие переменные должны «идти»</li>
						<li>Объект справа – существующий объект</li>
						<li>Список слева – список переменных, в которые записываются соответствующие свойства</li>
					</ul>
				</section>
				<section>
					<h3>Использование возвращающей функции</h3>
					<pre>
						<code class="hljs">
var calc = function(num) {
  return Math.pow(num, 2);
};

var { prop: x, pow: y = calc(x)} = { prop: 4 };
console.log(x, y); // 4 16

var { prop: x, pow: y = calc(x)} = { prop: 4, pow: 10 };
console.log(x, y); // 4 10
						</code>
					</pre>
				</section>
				<section>
					<h3>Простой пример</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

console.log(title);  // Меню
console.log(width);  // 100
console.log(height); // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Другое имя переменной</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {width: w, height: h, title} = options;

console.log(title);  // Меню
console.log(w);      // 100
console.log(h);      // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Значение по умолчанию</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню"
};

let {width=100, height=200, title} = options;

console.log(title);  // Меню
console.log(width);  // 100
console.log(height); // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Combo: новое имя + значение по умолчанию</h3>
					<pre>
						<code class="hljs">
let options = {
  title: "Меню"
};

let {width:w=100, height:h=200, title} = options;

console.log(title);  // Меню
console.log(w);      // 100
console.log(h);      // 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Отделение объявления от присваивания</h3>
					<pre>
						<code class="hljs">
var width, height;
({width, height} = {width: 100,height: 200});
console.log(width);// 100
console.log(height);// 200
						</code>
					</pre>
				</section>
				<section>
					<h3>Использование конкретного имени</h3>
					<pre>
						<code class="hljs">
let key = "title";
let { [key]: t } = {title: "Меню"};

console.log(t); // Меню
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Вложенные деструктуризации</h2>
				<pre>
					<code class="hljs">
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Пончик", "Пирожное"]
}

let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

// Меню 100 200 Пончик Пирожное
console.log(title);  // Меню
console.log(width);  // 100
console.log(height); // 200
console.log(item1);  // Пончик
console.log(item2);  // Пирожное
					</code>
				</pre>
			</section>
			<section>
				<h1>Функции</h1>
			</section>
			<section>
				<section>
					<h2>Параметры по умолчанию</h2>
					<pre>
					<code class="hljs">
function [name]([param1[ = defaultValue1 ][, ..., paramN[ = defaultValueN ]]]) {
   //function's body
}
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
function multiply(a, b = 1) {
  return a*b;
}

multiply(5); // 5
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример с undefined</h3>
					<blockquote>
						Даже при явном указании undefined параметру присваивается значение по умолчанию
					</blockquote>
					<pre>
						<code class="hljs">
function multiply(a, b = 1) {
  return a*b;
}

multiply(5, undefined); // 5		
						</code>
					</pre>
				</section>
				<section>
					<h3>Вычисление во время вызова</h3>
					<pre>
						<code class="hljs">
function append(value, array = []) {
  array.push(value);
  return array;
}

append(1); //[1]
append(2); //[2]
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример с функцией</h3>
					<pre>
						<code class="hljs">
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function print(number = getRandomInt(10, 100)){
   console.log(number);
}
print();//29
						</code>
					</pre>
				</section>
				<section>
					<h3>Оператор spread</h3>
					<blockquote>
						В отличии от arguments, rest - массив, а значит, можно использовать методы map, forEach и другие
					</blockquote>
					<pre>
						<code class="hljs">
function printName(firstName, lastName, ...rest) {
  console.log(firstName + ' ' + lastName + ' - ' + rest);
  console.log(rest);
}
printName('Иван', 'Иванов', 'Иванович', '1959');
//Иван Иванов - Иванович,1959
//["Иванович", "1959"]
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство name</h3>
					function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min)) + min; } console.log(getRandomInt.name);//getRandomInt
					getRandomInt.name = 'f'; console.log(getRandomInt.name); //getRandomInt console.log(f.name);// ReferenceError: f is
					not defined
				</section>
				<section>
					<h3>Блочная модель видимости</h3>
					<pre>
						<code class="hljs">
if(something){
getRandomInt(0, 10);//4
	function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}
}

getRandomInt(0, 10);//ReferenceError: getRandomInt is not defined
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Стрелочные функции</h2>
					<blockquote>
						Выражения имеют более короткий синтаксис и лексически привязаны к значению this, всегда анонимные
					</blockquote>
					<pre>
					<code class="hljs" data-trim>
						(param1, param2, paramN) => expression
					</code>
						</pre>
						<small>
					<ul>
						<li>Лексическое связывание. Значения this, super и arguments определяются не тем, как стрелочные
							функции были вызваны, а тем, как они были созданы</li>
						<li>Неизменяемые this, super и arguments. Значения этих переменных внутри стрелочных функций остаются неизменными на протяжении
							всего жизненного цикла функции</li>
						<li>Стрелочные функции не могут быть использованы как конструктор</li>
						<li>Недоступность «собственного» значения переменной arguments</li>
					</ul>
					</small>
				</section>
				<section>
					<h3>Короткая запись</h3>
					<pre>
					<code class="hljs">
var faculties = [
  "ИТ",
  "ИЭФ",
  "ХТИТ"
];

var a = faculties.map(function(s){ return s.length });//[2,3,4]

var b = faculties.map( s => s.length);//[2,3,4]
					</code>
				</pre>
				</section>
				<section>
					<h3>Еще примеры</h3>
					<pre>
						<code class="hljs">
let square = x => x*x;
console.log(square(3));//9
						</code>
					</pre>

					<pre>
						<code class="hljs">
let sum => (x, y) => x + y;
console.log(sum(3,4));//7
						</code>
					</pre>
					<pre>
						<code class="hljs">
let getObject = () => ({ brand: 'BMW' });
console.log(getObject());//Object {brand: "BMW"}
						</code>
					</pre>

					<pre>
						<code class="hljs">
let func = () => 77;
console.log(func());//77
						</code>
					</pre>
				</section>
				<section>
					<h3>Отсутствие this</h3>
					<pre>
					<code class="hljs">
 var handler = {
    id: "123456",
    init: function() {
        document.addEventListener("click", ev => this.doSomething(ev.type));
        //this указывает на внешний контекст
    },
    doSomething: function(type) { 
        console.log("Handling " + type  + " for " + this.id);
    }
};
					</code>
				</pre>
				</section>
				<section>
					<h3>Отсутствие arguments</h3>
					<pre>
						<code class="hljs">
function foo() {
  var f = (i) => arguments[0]+i;
  //возмет arguments из функции foo
  console.log(f(2));
}

foo(1); // 3
						</code>
					</pre>
				</section>
				<section>
					<h3>Отсутсвие запуска с new</h3>
					<pre>
						<code class="hljs">
var a = new (function() {}); 
// переменной a будет присвоено значение экземпляра анонимной функции

var b = new (() => {}); 
//TypeError: (intermediate value) is not a constructor
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/thanks.jpg" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>